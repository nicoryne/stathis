name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_backend:
        description: "Deploy backend"
        type: boolean
        default: true
        required: true
      deploy_frontend:
        description: "Deploy frontend"
        type: boolean
        default: true
        required: true
      run_health_checks:
        description: "Run post-deploy health checks"
        type: boolean
        default: true
        required: true

jobs:
  deploy-check:
    name: Secrets Check
    runs-on: ubuntu-latest
    permissions:
      contents: read
    concurrency:
      group: deploy-check
      cancel-in-progress: true
    steps:
      - name: Validate server SSH secrets are present
        env:
          H: ${{ secrets.DO_HOST }}
          U: ${{ secrets.DO_USERNAME }}
          K: ${{ secrets.DO_SSH_KEY }}
        run: |
          [ -z "$H" ] && echo "Missing secret: DO_HOST" && exit 1 || true
          [ -z "$U" ] && echo "Missing secret: DO_USERNAME" && exit 1 || true
          [ -z "$K" ] && echo "Missing secret: DO_SSH_KEY" && exit 1 || true
  
  deploy:
    name: Build and Deploy to VPS
    runs-on: ubuntu-latest
    permissions:
      contents: read
    concurrency:
      group: deploy-production
      cancel-in-progress: true
    env:
      SSH_HOST: ${{ secrets.DO_HOST }}
      SSH_USER: ${{ secrets.DO_USERNAME }}
      SSH_KEY: ${{ secrets.DO_SSH_KEY }}
      REMOTE_BASE: /root/stathis
      REMOTE_BACKEND_DIR: /root/stathis/backend/backend
      REMOTE_FRONTEND_DIR: /root/stathis/frontend/frontend
      # Flags: on manual run use inputs; on push default to true
      DEPLOY_BACKEND: ${{ github.event_name == 'workflow_dispatch' && inputs.deploy_backend || 'true' }}
      DEPLOY_FRONTEND: ${{ github.event_name == 'workflow_dispatch' && inputs.deploy_frontend || 'true' }}
      RUN_HEALTH_CHECKS: ${{ github.event_name == 'workflow_dispatch' && inputs.run_health_checks || 'true' }}
    steps:
      - uses: actions/checkout@v4

      # Build backend Spring Boot jar (skip tests for speed)
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
      - name: Build backend jar
        if: env.DEPLOY_BACKEND == 'true'
        working-directory: backend/stathis
        run: |
          chmod +x mvnw || true
          ./mvnw -q -B -DskipTests package
          ls -la target
          JAR_PATH=$(ls target/*.jar | head -n1)
          echo "JAR_PATH=$(pwd)/$JAR_PATH" >> $GITHUB_ENV
      - name: Rename jar to server.jar
        if: env.DEPLOY_BACKEND == 'true'
        run: |
          cp "$JAR_PATH" server.jar

      # Build Android APK
      - name: Set up JDK 17 for Android
        if: env.DEPLOY_FRONTEND == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Setup Android SDK
        if: env.DEPLOY_FRONTEND == 'true'
        uses: android-actions/setup-android@v3
      - name: Build Android APK
        if: env.DEPLOY_FRONTEND == 'true'
        working-directory: mobile/stathis-mobile
        run: |
          chmod +x gradlew || true
          ./gradlew assembleDebug
          APK_PATH=$(find app/build/outputs/apk/debug -name "*.apk" | head -n1)
          echo "APK_PATH=$(pwd)/$APK_PATH" >> $GITHUB_ENV
          echo "APK_NAME=$(basename $APK_PATH)" >> $GITHUB_ENV
      - name: Copy APK to web public folder
        if: env.DEPLOY_FRONTEND == 'true'
        run: |
          mkdir -p web/stathis-web/public/downloads
          cp "$APK_PATH" "web/stathis-web/public/downloads/stathis-mobile.apk"
          echo "APK copied to web public folder"

      # Prebuild frontend (Next.js) and prepare artifacts
      - name: Setup Node.js
        if: env.DEPLOY_FRONTEND == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install deps and build frontend
        if: env.DEPLOY_FRONTEND == 'true'
        working-directory: web/stathis-web
        run: |
          npm install --no-audit --no-fund
          npm run build
      - name: Package prebuilt .next
        if: env.DEPLOY_FRONTEND == 'true'
        working-directory: web/stathis-web
        run: |
          tar -czf ../../frontend-next.tgz .next
      - name: Compress frontend source for transfer (non-building runtime)
        if: env.DEPLOY_FRONTEND == 'true'
        run: |
          tar -czf frontend.tgz -C web/stathis-web .

      # Copy artifacts to server
      - name: Upload backend server.jar
        if: env.DEPLOY_BACKEND == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "server.jar"
          target: "${{ env.REMOTE_BACKEND_DIR }}"
          strip_components: 0
          overwrite: true
          rm: false
      - name: Upload frontend bundle
        if: env.DEPLOY_FRONTEND == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "frontend.tgz"
          target: "${{ env.REMOTE_FRONTEND_DIR }}/.."
          strip_components: 0
      - name: Upload prebuilt .next bundle
        if: env.DEPLOY_FRONTEND == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "frontend-next.tgz"
          target: "${{ env.REMOTE_FRONTEND_DIR }}/.."
          strip_components: 0

      # Deploy and restart services via docker compose
      - name: Restart services on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          script: |
            set -euo pipefail
            cd "${{ env.REMOTE_BASE }}"
            # Place frontend files when requested
            if [ "${{ env.DEPLOY_FRONTEND }}" = "true" ]; then
              mkdir -p "${{ env.REMOTE_FRONTEND_DIR }}"
              tar -xzf "${{ env.REMOTE_FRONTEND_DIR }}/../frontend.tgz" -C "${{ env.REMOTE_FRONTEND_DIR }}"
              rm -f "${{ env.REMOTE_FRONTEND_DIR }}/../frontend.tgz"
              # Extract prebuilt .next into the runtime directory
              tar -xzf "${{ env.REMOTE_FRONTEND_DIR }}/../frontend-next.tgz" -C "${{ env.REMOTE_FRONTEND_DIR }}"
              rm -f "${{ env.REMOTE_FRONTEND_DIR }}/../frontend-next.tgz"
            fi
            # Ensure backend jar is in place when deploying backend
            if [ "${{ env.DEPLOY_BACKEND }}" = "true" ]; then
              test -f "${{ env.REMOTE_BACKEND_DIR }}/server.jar" || { echo "server.jar is missing"; exit 1; }
            fi
            # Restart only the services we updated
            SERVICES=""
            if [ "${{ env.DEPLOY_BACKEND }}" = "true" ]; then SERVICES="$SERVICES stathis-backend"; fi
            if [ "${{ env.DEPLOY_FRONTEND }}" = "true" ]; then SERVICES="$SERVICES stathis-frontend"; fi
            if [ -n "$SERVICES" ]; then
              docker compose up -d --force-recreate --no-deps $SERVICES
            else
              echo "No services selected for restart. Skipping."
            fi
            # Optional health checks (use container health status)
            if [ "${{ env.RUN_HEALTH_CHECKS }}" = "true" ]; then
              echo "Waiting for service health statuses..."
              if [ "${{ env.DEPLOY_FRONTEND }}" = "true" ]; then
                echo "Waiting for stathis-frontend to be healthy (max 5 minutes) ..."
                for i in $(seq 1 60); do
                  STATUS=$(docker inspect -f '{{json .State.Health.Status}}' stathis-frontend 2>/dev/null | tr -d '"') || STATUS=""
                  if [ "$STATUS" = "healthy" ]; then echo "Frontend healthy"; break; fi; sleep 5; done
                STATUS=$(docker inspect -f '{{json .State.Health.Status}}' stathis-frontend 2>/dev/null | tr -d '"') || STATUS=""
                if [ "$STATUS" != "healthy" ]; then echo "Frontend unhealthy or no healthcheck"; docker compose logs --no-color --tail 300 stathis-frontend; exit 1; fi
              fi
              if [ "${{ env.DEPLOY_BACKEND }}" = "true" ]; then
                echo "Waiting for stathis-backend to be healthy (max 2 minutes) ..."
                for i in $(seq 1 24); do
                  STATUS=$(docker inspect -f '{{json .State.Health.Status}}' stathis-backend 2>/dev/null | tr -d '"') || STATUS=""
                  if [ "$STATUS" = "healthy" ]; then echo "Backend healthy"; break; fi; sleep 5; done
                STATUS=$(docker inspect -f '{{json .State.Health.Status}}' stathis-backend 2>/dev/null | tr -d '"') || STATUS=""
                if [ "$STATUS" != "healthy" ]; then echo "Backend unhealthy or no healthcheck"; docker compose logs --no-color --tail 300 stathis-backend; exit 1; fi
              fi
            fi
            docker system prune -f || true
            echo "Deployment complete."
