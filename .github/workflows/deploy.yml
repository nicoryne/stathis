name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_backend:
        description: "Deploy backend"
        type: boolean
        default: true
        required: true
      deploy_frontend:
        description: "Deploy frontend"
        type: boolean
        default: true
        required: true
      run_health_checks:
        description: "Run post-deploy health checks"
        type: boolean
        default: true
        required: true

jobs:
  deploy-check:
    name: Secrets Check
    runs-on: ubuntu-latest
    permissions:
      contents: read
    concurrency:
      group: deploy-check
      cancel-in-progress: true
    steps:
      - name: Validate server SSH secrets are present
        env:
          H: ${{ secrets.DO_HOST }}
          U: ${{ secrets.DO_USERNAME }}
          K: ${{ secrets.DO_SSH_KEY }}
        run: |
          [ -z "$H" ] && echo "Missing secret: DO_HOST" && exit 1 || true
          [ -z "$U" ] && echo "Missing secret: DO_USERNAME" && exit 1 || true
          [ -z "$K" ] && echo "Missing secret: DO_SSH_KEY" && exit 1 || true
  
  deploy:
    name: Build and Deploy to VPS
    runs-on: ubuntu-latest
    permissions:
      contents: read
    concurrency:
      group: deploy-production
      cancel-in-progress: true
    env:
      SSH_HOST: ${{ secrets.DO_HOST }}
      SSH_USER: ${{ secrets.DO_USERNAME }}
      SSH_KEY: ${{ secrets.DO_SSH_KEY }}
      REMOTE_BASE: /root/stathis
      REMOTE_BACKEND_DIR: /root/stathis/backend/backend
      REMOTE_FRONTEND_DIR: /root/stathis/frontend/frontend
      # Flags: on manual run use inputs; on push default to true
      DEPLOY_BACKEND: ${{ github.event_name == 'workflow_dispatch' && inputs.deploy_backend || 'true' }}
      DEPLOY_FRONTEND: ${{ github.event_name == 'workflow_dispatch' && inputs.deploy_frontend || 'true' }}
      RUN_HEALTH_CHECKS: ${{ github.event_name == 'workflow_dispatch' && inputs.run_health_checks || 'true' }}
    steps:
      - uses: actions/checkout@v4

      # Build backend Spring Boot jar (skip tests for speed)
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
      - name: Build backend jar
        if: env.DEPLOY_BACKEND == 'true'
        working-directory: backend/stathis
        run: |
          chmod +x mvnw || true
          ./mvnw -q -B -DskipTests package
          ls -la target
          JAR_PATH=$(ls target/*.jar | head -n1)
          echo "JAR_PATH=$(pwd)/$JAR_PATH" >> $GITHUB_ENV
      - name: Rename jar to server.jar
        if: env.DEPLOY_BACKEND == 'true'
        run: |
          cp "$JAR_PATH" server.jar

      # Prebuild frontend (Next.js) and prepare artifacts
      - name: Setup Node.js
        if: env.DEPLOY_FRONTEND == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install deps and build frontend
        if: env.DEPLOY_FRONTEND == 'true'
        working-directory: web/stathis-web
        run: |
          npm install --no-audit --no-fund
          npm run build
      - name: Package prebuilt .next
        if: env.DEPLOY_FRONTEND == 'true'
        working-directory: web/stathis-web
        run: |
          tar -czf ../../frontend-next.tgz .next
      - name: Compress frontend source for transfer (non-building runtime)
        if: env.DEPLOY_FRONTEND == 'true'
        run: |
          tar -czf frontend.tgz -C web/stathis-web .

      # Copy artifacts to server
      - name: Upload backend server.jar
        if: env.DEPLOY_BACKEND == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "server.jar"
          target: "${{ env.REMOTE_BACKEND_DIR }}"
          strip_components: 0
          overwrite: true
          rm: false
      - name: Upload frontend bundle
        if: env.DEPLOY_FRONTEND == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "frontend.tgz"
          target: "${{ env.REMOTE_FRONTEND_DIR }}/.."
          strip_components: 0
      - name: Upload prebuilt .next bundle
        if: env.DEPLOY_FRONTEND == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          source: "frontend-next.tgz"
          target: "${{ env.REMOTE_FRONTEND_DIR }}/.."
          strip_components: 0

      # Deploy and restart services via docker compose
      - name: Restart services on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          script: |
            set -euo pipefail
            cd "${{ env.REMOTE_BASE }}"
            # Place frontend files when requested
            if [ "${{ env.DEPLOY_FRONTEND }}" = "true" ]; then
              mkdir -p "${{ env.REMOTE_FRONTEND_DIR }}"
              tar -xzf "${{ env.REMOTE_FRONTEND_DIR }}/../frontend.tgz" -C "${{ env.REMOTE_FRONTEND_DIR }}"
              rm -f "${{ env.REMOTE_FRONTEND_DIR }}/../frontend.tgz"
              # Extract prebuilt .next into the runtime directory
              tar -xzf "${{ env.REMOTE_FRONTEND_DIR }}/../frontend-next.tgz" -C "${{ env.REMOTE_FRONTEND_DIR }}"
              rm -f "${{ env.REMOTE_FRONTEND_DIR }}/../frontend-next.tgz"
              # Adjust compose to skip build at runtime (use npm install + start)
              sed -i 's/npm install &&\s*npm run build &&\s*npm run start/npm install \&\& npm run start/g' docker-compose.yml || true
            fi
            # Ensure backend jar is in place when deploying backend
            if [ "${{ env.DEPLOY_BACKEND }}" = "true" ]; then
              test -f "${{ env.REMOTE_BACKEND_DIR }}/server.jar" || { echo "server.jar is missing"; exit 1; }
            fi
            # Restart only the services we updated
            SERVICES=""
            if [ "${{ env.DEPLOY_BACKEND }}" = "true" ]; then SERVICES="$SERVICES stathis-backend"; fi
            if [ "${{ env.DEPLOY_FRONTEND }}" = "true" ]; then SERVICES="$SERVICES stathis-frontend"; fi
            if [ -n "$SERVICES" ]; then
              docker compose up -d --force-recreate --no-deps $SERVICES
            else
              echo "No services selected for restart. Skipping."
            fi
            # Optional health checks
            if [ "${{ env.RUN_HEALTH_CHECKS }}" = "true" ]; then
              echo "Waiting for containers to settle..."
              # Retry loop up to 3 minutes for frontend since npm install may take time
              if [ "${{ env.DEPLOY_FRONTEND }}" = "true" ]; then
                echo "Probing frontend via Docker network ..."
                for i in $(seq 1 36); do
                  if docker run --rm --network stathis-network curlimages/curl:8.6.0 -fsS http://stathis-frontend:3000 >/dev/null; then
                    echo "Frontend is healthy"; break; fi; sleep 5; done
                if ! docker run --rm --network stathis-network curlimages/curl:8.6.0 -fsS http://stathis-frontend:3000 >/dev/null; then
                  echo "Frontend failed"; docker compose logs --no-color --tail 300 stathis-frontend; exit 1; fi
              fi
              # Backend: faster boot, but still retry up to 60s
              if [ "${{ env.DEPLOY_BACKEND }}" = "true" ]; then
                echo "Probing backend via Docker network ..."
                for i in $(seq 1 12); do
                  if docker run --rm --network stathis-network curlimages/curl:8.6.0 -fsS http://stathis-backend:8080/actuator/health >/dev/null; then
                    echo "Backend is healthy"; break; fi; sleep 5; done
                if ! docker run --rm --network stathis-network curlimages/curl:8.6.0 -fsS http://stathis-backend:8080/actuator/health >/dev/null; then
                  echo "Backend failed"; docker compose logs --no-color --tail 300 stathis-backend; exit 1; fi
              fi
            fi
            docker system prune -f || true
            echo "Deployment complete."
